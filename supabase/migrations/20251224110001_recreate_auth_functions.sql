-- This script ensures that the necessary authorization functions and tables exist.

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
        CREATE TYPE public.user_role AS ENUM ('admin', 'user');
    END IF;
END$$;

CREATE TABLE IF NOT EXISTS public.user_roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role user_role NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, role)
);

COMMENT ON TABLE public.user_roles IS 'Stores user roles';

CREATE OR REPLACE FUNCTION public.get_user_role(_user_id UUID)
RETURNS TABLE(role user_role) AS $$
BEGIN
    -- Anonymous users don't have roles
    IF _user_id IS NULL THEN
        RETURN QUERY SELECT NULL::user_role;
        RETURN;
    END IF;

    RETURN QUERY
    SELECT ur.role
    FROM public.user_roles ur
    WHERE ur.user_id = _user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.has_role(_role user_role, _user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    -- Anonymous users don't have roles
    IF _user_id IS NULL THEN
        RETURN FALSE;
    END IF;

    RETURN EXISTS (
        SELECT 1
        FROM public.user_roles
        WHERE user_roles.user_id = _user_id
        AND user_roles.role = _role
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- Drop the policy if it exists, then create it.
DROP POLICY IF EXISTS "Can view own user role" ON public.user_roles;
CREATE POLICY "Can view own user role" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);
